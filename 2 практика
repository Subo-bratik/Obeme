1. Бинарная куча
Python

import heapq

class BinaryHeap:
    def __init__(self):
        self.heap = []
    
    def push(self, item):
        heapq.heappush(self.heap, item)
    
    def pop(self):
        return heapq.heappop(self.heap) if self.heap else None
    
    def peek(self):
        return self.heap[0] if self.heap else None
    
    def __len__(self):
        return len(self.heap)

# Использование
heap = BinaryHeap()
heap.push(5)
heap.push(2)
heap.push(8)
print(f"Min: {heap.pop()}")  # 2

C++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class BinaryHeap {
private:
    vector<int> heap;
    
    void heapify_up(int index) {
        while (index > 0 && heap[(index-1)/2] > heap[index]) {
            swap(heap[(index-1)/2], heap[index]);
            index = (index-1)/2;
        }
    }
    
    void heapify_down(int index) {
        int left = 2*index + 1;
        int right = 2*index + 2;
        int smallest = index;
        
        if (left < heap.size() && heap[left] < heap[smallest])
            smallest = left;
        if (right < heap.size() && heap[right] < heap[smallest])
            smallest = right;
            
        if (smallest != index) {
            swap(heap[index], heap[smallest]);
            heapify_down(smallest);
        }
    }
    
public:
    void push(int item) {
        heap.push_back(item);
        heapify_up(heap.size()-1);
    }
    
    int pop() {
        if (heap.empty()) throw runtime_error("Heap empty");
        int root = heap[0];
        heap[0] = heap.back();
        heap.pop_back();
        if (!heap.empty()) heapify_down(0);
        return root;
    }
    
    int peek() {
        if (heap.empty()) throw runtime_error("Heap empty");
        return heap[0];
    }
    
    size_t size() { return heap.size(); }
};

// Использование
int main() {
    BinaryHeap heap;
    heap.push(5);
    heap.push(2);
    heap.push(8);
    cout << "Min: " << heap.pop() << endl;  // 2
    return 0;
}

Java
import java.util.*;

class BinaryHeap {
    private List<Integer> heap;
    
    public BinaryHeap() {
        heap = new ArrayList<>();
    }
    
    private void heapifyUp(int index) {
        while (index > 0 && heap.get((index-1)/2) > heap.get(index)) {
            Collections.swap(heap, (index-1)/2, index);
            index = (index-1)/2;
        }
    }
    
    private void heapifyDown(int index) {
        int left = 2*index + 1;
        int right = 2*index + 2;
        int smallest = index;
        
        if (left < heap.size() && heap.get(left) < heap.get(smallest))
            smallest = left;
        if (right < heap.size() && heap.get(right) < heap.get(smallest))
            smallest = right;
            
        if (smallest != index) {
            Collections.swap(heap, index, smallest);
            heapifyDown(smallest);
        }
    }
    
    public void push(int item) {
        heap.add(item);
        heapifyUp(heap.size()-1);
    }
    
    public int pop() {
        if (heap.isEmpty()) throw new NoSuchElementException("Heap empty");
        int root = heap.get(0);
        heap.set(0, heap.get(heap.size()-1));
        heap.remove(heap.size()-1);
        if (!heap.isEmpty()) heapifyDown(0);
        return root;
    }
    
    public int peek() {
        if (heap.isEmpty()) throw new NoSuchElementException("Heap empty");
        return heap.get(0);
    }
    
    public int size() { return heap.size(); }
}

// Использование
class Main {
    public static void main(String[] args) {
        BinaryHeap heap = new BinaryHeap();
        heap.push(5);
        heap.push(2);
        heap.push(8);
        System.out.println("Min: " + heap.pop());  // 2
    }
}

2. Хеш-таблица
Python
class HashTable:
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]
    
    def _hash(self, key):
        return hash(key) % self.size
    
    def put(self, key, value):
        index = self._hash(key)
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                self.table[index][i] = (key, value)
                return
        self.table[index].append((key, value))
    
    def get(self, key):
        index = self._hash(key)
        for k, v in self.table[index]:
            if k == key:
                return v
        raise KeyError(f"Key {key} not found")
    
    def remove(self, key):
        index = self._hash(key)
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                del self.table[index][i]
                return
        raise KeyError(f"Key {key} not found")

# Использование
ht = HashTable()
ht.put("name", "Alice")
print(ht.get("name"))  # Alice

C++
#include <iostream>
#include <vector>
#include <list>
#include <functional>
using namespace std;

template<typename K, typename V>
class HashTable {
private:
    vector<list<pair<K, V>>> table;
    size_t capacity;
    
    size_t hash(const K& key) {
        return hash<K>{}(key) % capacity;
    }
    
public:
    HashTable(size_t size = 10) : capacity(size) {
        table.resize(capacity);
    }
    
    void put(const K& key, const V& value) {
        size_t index = hash(key);
        for (auto& pair : table[index]) {
            if (pair.first == key) {
                pair.second = value;
                return;
            }
        }
        table[index].push_back({key, value});
    }
    
    V get(const K& key) {
        size_t index = hash(key);
        for (auto& pair : table[index]) {
            if (pair.first == key) {
                return pair.second;
            }
        }
        throw runtime_error("Key not found");
    }
    
    void remove(const K& key) {
        size_t index = hash(key);
        for (auto it = table[index].begin(); it != table[index].end(); ++it) {
            if (it->first == key) {
                table[index].erase(it);
                return;
            }
        }
        throw runtime_error("Key not found");
    }
};

// Использование
int main() {
    HashTable<string, string> ht;
    ht.put("name", "Alice");
    cout << ht.get("name") << endl;  // Alice
    return 0;
}

Java
import java.util.*;

class HashTable<K, V> {
    private LinkedList<Entry<K, V>>[] table;
    private int capacity;
    
    private static class Entry<K, V> {
        K key;
        V value;
        Entry(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }
    
    @SuppressWarnings("unchecked")
    public HashTable(int capacity) {
        this.capacity = capacity;
        table = new LinkedList[capacity];
        for (int i = 0; i < capacity; i++) {
            table[i] = new LinkedList<>();
        }
    }
    
    private int hash(K key) {
        return Math.abs(key.hashCode()) % capacity;
    }
    
    public void put(K key, V value) {
        int index = hash(key);
        for (Entry<K, V> entry : table[index]) {
            if (entry.key.equals(key)) {
                entry.value = value;
                return;
            }
        }
        table[index].add(new Entry<>(key, value));
    }
    
    public V get(K key) {
        int index = hash(key);
        for (Entry<K, V> entry : table[index]) {
            if (entry.key.equals(key)) {
                return entry.value;
            }
        }
        throw new NoSuchElementException("Key not found");
    }
    
    public void remove(K key) {
        int index = hash(key);
        Iterator<Entry<K, V>> iterator = table[index].iterator();
        while (iterator.hasNext()) {
            Entry<K, V> entry = iterator.next();
            if (entry.key.equals(key)) {
                iterator.remove();
                return;
            }
        }
        throw new NoSuchElementException("Key not found");
    }
}

// Использование
class Main {
    public static void main(String[] args) {
        HashTable<String, String> ht = new HashTable<>(10);
        ht.put("name", "Alice");
        System.out.println(ht.get("name"));  // Alice
    }
}

3. Куча Фибоначчи 
Python
class FibonacciHeap:
    class Node:
        def __init__(self, key, value):
            self.key = key
            self.value = value
            self.degree = 0
            self.marked = False
            self.parent = None
            self.child = None
            self.left = self
            self.right = self
    
    def __init__(self):
        self.min_node = None
        self.count = 0
    
    def insert(self, key, value):
        node = self.Node(key, value)
        if self.min_node is None:
            self.min_node = node
        else:
            self._add_to_root_list(node)
            if key < self.min_node.key:
                self.min_node = node
        self.count += 1
        return node
    
    def _add_to_root_list(self, node):
        node.left = self.min_node
        node.right = self.min_node.right
        self.min_node.right.left = node
        self.min_node.right = node

# Использование
fib_heap = FibonacciHeap()
fib_heap.insert(5, "A")
fib_heap.insert(2, "B")

C++
#include <iostream>
using namespace std;

class FibonacciHeap {
    struct Node {
        int key;
        string value;
        int degree;
        bool marked;
        Node* parent;
        Node* child;
        Node* left;
        Node* right;
        
        Node(int k, string v) : key(k), value(v), degree(0), marked(false),
                               parent(nullptr), child(nullptr), left(this), right(this) {}
    };
    
    Node* min_node;
    int count;
    
    void add_to_root_list(Node* node) {
        node->left = min_node;
        node->right = min_node->right;
        min_node->right->left = node;
        min_node->right = node;
    }
    
public:
    FibonacciHeap() : min_node(nullptr), count(0) {}
    
    Node* insert(int key, string value) {
        Node* node = new Node(key, value);
        if (!min_node) {
            min_node = node;
        } else {
            add_to_root_list(node);
            if (key < min_node->key) {
                min_node = node;
            }
        }
        count++;
        return node;
    }
};

// Использование
int main() {
    FibonacciHeap fib_heap;
    fib_heap.insert(5, "A");
    fib_heap.insert(2, "B");
    return 0;
}

Java
class FibonacciHeap {
    class Node {
        int key;
        String value;
        int degree;
        boolean marked;
        Node parent;
        Node child;
        Node left;
        Node right;
        
        Node(int key, String value) {
            this.key = key;
            this.value = value;
            this.degree = 0;
            this.marked = false;
            this.parent = null;
            this.child = null;
            this.left = this;
            this.right = this;
        }
    }
    
    private Node minNode;
    private int count;
    
    private void addToRootList(Node node) {
        node.left = minNode;
        node.right = minNode.right;
        minNode.right.left = node;
        minNode.right = node;
    }
    
    public Node insert(int key, String value) {
        Node node = new Node(key, value);
        if (minNode == null) {
            minNode = node;
        } else {
            addToRootList(node);
            if (key < minNode.key) {
                minNode = node;
            }
        }
        count++;
        return node;
    }
}

// Использование
class Main {
    public static void main(String[] args) {
        FibonacciHeap fibHeap = new FibonacciHeap();
        fibHeap.insert(5, "A");
        fibHeap.insert(2, "B");
    }
}
